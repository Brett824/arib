# vim: set ts=2 expandtab:
# -*- coding: utf-8 -*-
'''
Module: ass.py
Desc: WebVTT formatter for ARIB subtitles
Author: John O'Neil
Email: oneil.john@gmail.com
DATE: Wednesday, Jan 18th 2017

Leveraging WebVTT due to simpler resultant file format.
More readable. Easier to maintain.
Line breaks in areas could screw things up, but I'm
assuming we can work around that.
  
'''

import arib.code_set as code_set
import arib.control_characters as control_characters
import codecs
import re

class Pos(object):
  '''Screen position in pixels
  '''
  def __init__(self, x, y):
    self._x = x
    self._y = y

  @property
  def x(self):
    return self._x

  @property
  def y(self):
    return self._y

class Dialog(object):
  ''' text and dialog
  '''
  def __init__(self, s, x=None, y=None):
    self._s = s
    self._x = x
    self._y = y
  def __iadd__(self, other):
    self._s += other
    return self
  def __len__(self):
    return len(self._s)

class Size(object):
  '''Screen width, height of an area in pixels
  '''
  def __init__(self, w, h):
    self._w = w
    self._h = h

  @property
  def width(self):
    return self._w

  @property
  def height(self):
    return self._h


class ClosedCaptionArea(object):
  def __init__(self):
    self._UL = Pos(170, 30)
    self._Dimensions = Size(620, 480)
    self._CharacterDim = Size(36, 36)
    self._char_spacing = 4
    self._line_spacing = 24

  @property
  def UL(self):
    return self._UL

  @property
  def Dimensions(self):
    return self._Dimensions

  def RowCol2ScreenPos(self, row, col):
    # issue #13. Active Position Set values seem incorrect.
    # It doesn't jive with any documentation i've read but the APS values coming
    # out of some .ts files (specifically aijin) seem incorrect by a factor of 2.
    # According to text area data, there should be 8 text lines in the CC area but
    # values for CC APS values are 12-15.
    # I'm assuming (again with no documentation justification) that these values
    # are meant to provide sub-line positioning data, so we'll scale the APS data by 0.5
    # allowing positioning at, say, the 6.5th text line rather than just integer value lines.
    num_rows = int(self._Dimensions.height / (self._CharacterDim.height + self._line_spacing))
    num_cols = int(self._Dimensions.width / (self._CharacterDim.width + self._char_spacing))
    r = row
    if row >= num_rows:
      r = float(row-1)/2.0

    c = col
    if c >= num_cols:
      c = float(col-1)/2.0
    # note that character positions here are provided via row/col values, but
    # the actual position indicated by this is the UPPER LEFT HAND CORNER of that
    # position. To keep general formatting below in sync with this we're adjusting
    # the geometry here to return the UL corner by adding one horizontal row.
    return Pos(self.UL.x + c * (self._CharacterDim.width + self._char_spacing), self.UL.y + (r+1) * (self._CharacterDim.height + self._line_spacing))

class WebVTTFile(object):
  '''Wrapper for a single open utf-8 encoded WebVTT file we're writing to.
  '''
  def __init__(self, filepath):
    self._f = codecs.open(filepath,'w',encoding='utf8')

  def __del__(self):
    if self._f:
      self._f.close()

  def write(self, line):
    '''Write indicated string to file. usually a line of dialog.
    '''
    self._f.write(line)

  def write_header(self, width, height, title):
    header = u'''WebVTT file generated by arib-ts2webvtt
Video file: {title}
Width: {width}
Height {height}
WEBVTT

    '''.format(width=width, height=height, title=title)
    self._f.write(header)

  def write_styles(self):
    styles = u'''
    '''
    self._f.write(styles)

def strtime(seconds):
  '''format floating point seconds elapsed time to 0:02:14.53
  '''
  hrs = int(seconds / 3600)
  seconds -= 3600*hrs
  mins = int(seconds / 60)
  seconds -= 60*mins
  return u'{h:0d2}:{m:02d}:{s:02.3f}'.format(h=hrs, m=mins, s=seconds)

def next_cue(start_time_s, end_time_s):
    st = strtime(start_time_s)
    et = strtime(end_time_s)
    return u'\n{st} --> {et}'.format(st=st, et=et)

def kanji(formatter, k, timestamp):
  formatter._current_lines[-1] += unicode(k)
  #print unicode(k)

def alphanumeric(formatter, a, timestamp):
  formatter._current_lines[-1] += unicode(a)
  #print unicode(a)

def hiragana(formatter, h, timestamp):
  formatter._current_lines[-1] += unicode(h)
  #print unicode(h)

def katakana(formatter, k, timestamp):
  formatter._current_lines[-1] += unicode(k)
  #print unicode(k)

def medium(formatter, k, timestamp):
  #formatter._current_lines[-1] += u'{\\rmedium}' + formatter._current_color
  #formatter._current_style = 'medium'
  return u''

def normal(formatter, k, timestamp):
  #formatter._current_lines[-1] += u'{\\rnormal}' + formatter._current_color
  #formatter._current_style = 'normal'
  return u''

def small(formatter, k, timestamp):
  #formatter._current_lines[-1] += u'{\\rsmall}' + formatter._current_color
  #formatter._current_style = 'small'
  return u''

def space(formatter, k, timestamp):
  formatter._current_lines[-1] += u' '

def drcs(formatter, c, timestamp):
  formatter._current_lines[-1] += u'ï¿

def black(formatter, k, timestamp):
  #{\c&H000000&} \c&H<bb><gg><rr>& {\c&Hffffff&}
  #formatter._current_lines[-1] += u'{\c&H000000&}'
  #formatter._current_color = '{\c&H000000&}'
  return u''

def red(formatter, k, timestamp):
  #{\c&H0000ff&}
  #formatter._current_lines[-1] += u'{\c&H0000ff&}'
  #formatter._current_color = '{\c&H0000ff&}'
  return u''

def green(formatter, k, timestamp):
  #{\c&H00ff00&}
  #formatter._current_lines[-1] += u'{\c&H00ff00&}'
  #formatter._current_color = '{\c&H00ff00&}'
  return u''

def yellow(formatter, k, timestamp):
  #{\c&H00ffff&}
  #formatter._current_lines[-1] += u'{\c&H00ffff&}'
  #formatter._current_color = '{\c&H00ffff&}'
  return u''

def blue(formatter, k, timestamp):
  #{\c&Hff0000&}
  #formatter._current_lines[-1] += u'{\c&Hff0000&}'
  #formatter._current_color = '{\c&Hff0000&}'
  return u''

def magenta(formatter, k, timestamp):
  #{\c&Hff00ff&}
  #formatter._current_lines[-1] += u'{\c&Hff00ff&}'
  #formatter._current_color = '{\c&Hff00ff&}'
  return u''

def cyan(formatter, k, timestamp):
  #{\c&Hffff00&}
  #formatter._current_lines[-1] += u'{\c&Hffff00&}'
  #formatter._current_color = '{\c&Hffff00&}'
  return u''

def white(formatter, k, timestamp):
  #{\c&Hffffff&}
  #formatter._current_lines[-1] += u'{\c&Hffffff&}'
  #formatter._current_color = '{\c&Hffffff&}'
  return u''

def position_set(formatter, p, timestamp):
  '''Active Position set coordinates are given in character row, colum
  So we have to calculate pixel coordinates (and then sale them)
  '''
  #ipos = formatter._CCArea.RowCol2ScreenPos(p.row, p.col)
  #line = u'{{\\r{style}}}{color}{{\pos({x},{y})}}'.format(color=formatter._current_color, style=formatter._current_style, x=pos.x, y=pos.y)
  #formatter._current_lines.append(Dialog(line))
  return u''

a_regex = ur'<CS:"(?P<x>\d{1,4});(?P<y>\d{1,4}) a">'

def control_character(formatter, csi, timestamp):
  '''This will be the most difficult to format, since the same class here
  can represent so many different commands.
  e.g:
  <CS:"7 S"><CS:"170;30 _"><CS:"620;480 V"><CS:"36;36 W"><CS:"4 X"><CS:"24 Y"><Small Text><CS:"170;389 a">
  '''
  cmd = unicode(csi)
  a_match = re.search(a_regex, cmd)
  if a_match:
    # APS Control Sequences (absolute positioning of text as <CS: 170;389 a> above
    # indicate the LOWER LEFT HAND CORNER of text position.
    x = a_match.group('x')
    y = a_match.group('y')
    #formatter._current_lines.append( Dialog( u'{{\\r{style}}}{color}{{\\pos({x},{y})}}{{\\an1}}'.format(color=formatter._current_color, style=formatter._current_style, x=x, y=y)))
    return

pos_regex = ur'({\\pos\(\d{1,4},\d{1,4}\)})'

def clear_screen(formatter, cs, timestamp):

  if(timestamp - formatter._elapsed_time_s > formatter._tmax):
    end_time = strtime(formatter._elapsed_time_s + formatter._tmax)
  else:
    end_time = strtime(timestamp)
  start_time = strtime(formatter._elapsed_time_s)

  if (len(formatter._current_lines[0]) or len(formatter._current_lines)) and start_time != end_time:
    formatter._ass_file.write(next_cue(start_time, end_time))
    for l in reversed(formatter._current_lines):
      if not len(l):
        continue
      formatter._ass_file.write(l)
      formatter._current_lines = [Dialog(u'')]
  formatter._elapsed_time_s = timestamp
  

class WebVTTFormatter(object):
  '''
  '''

  DISPLAYED_CC_STATEMENTS = {
    code_set.Kanji : kanji,
    code_set.Alphanumeric : alphanumeric,
    code_set.Hiragana : hiragana,
    code_set.Katakana : katakana,
    control_characters.APS : position_set,#{\pos(<X>,<Y>)}
    control_characters.MSZ : medium, #{\rmedium}
    control_characters.NSZ : normal, #{\rnormal}
    control_characters.SP : space, #' '
    control_characters.SSZ : small, #{\rsmall}
    control_characters.CS : clear_screen,
    control_characters.CSI : control_character, #{\pos(<X>,<Y>)}
    #control_characters.COL,
    control_characters.BKF : black,#{\c&H000000&} \c&H<bb><gg><rr>&
    control_characters.RDF : red,#{\c&H0000ff&}
    control_characters.GRF : green,#{\c&H00ff00&}
    control_characters.YLF : yellow,#{\c&H00ffff&}
    control_characters.BLF : blue,#{\c&Hff0000&}
    control_characters.MGF : magenta,#{\c&Hff00ff&}
    control_characters.CNF : cyan,#{\c&Hffff00&}
    control_characters.WHF : white,#{\c&Hffffff&}

    #largely unhandled DRCS just replaces them with unicode unknown character square
    code_set.DRCS0 : drcs,
    code_set.DRCS1 : drcs,
    code_set.DRCS2 : drcs,
    code_set.DRCS3 : drcs,
    code_set.DRCS4 : drcs,
    code_set.DRCS5 : drcs,
    code_set.DRCS6 : drcs,
    code_set.DRCS7 : drcs,
    code_set.DRCS8 : drcs,
    code_set.DRCS9 : drcs,
    code_set.DRCS10 : drcs,
    code_set.DRCS11 : drcs,
    code_set.DRCS12 : drcs,
    code_set.DRCS13 : drcs,
    code_set.DRCS14 : drcs,
    code_set.DRCS15 : drcs,

  }


  def __init__(self, ass_file=None, default_color='white', tmax=5, width=960, height=540, video_filename='unknown'):
    '''
    :param width: width of target screen in pixels
    :param height: height of target screen in pixels
    :param format_callback: callback method of form <None>callback(string) that
    can be used to dump strings to file upon each subsequent "clear screen" command.
    '''
    self._color = default_color
    self._tmax = tmax
    self._CCArea = ClosedCaptionArea()
    self._pos = Pos(0, 0)
    self._elapsed_time_s = 0.0
    self._ass_file = ass_file
    self._ass_file.write_header(width,height, video_filename.decode("utf-8"))
    self._ass_file.write_styles()
    self._current_lines = [Dialog(u'')]
    self._current_style = 'normal'
    self._current_color = '{\c&Hffffff&}'

  def format(self, captions, timestamp):
    '''Format ARIB closed caption info tinto text for an .ASS file
    '''
    #TODO: Show progress in some way
    #print('File elapsed time seconds: {s}'.format(s=timestamp))
    #line = u'{t}: {l}\n'.format(t=timestamp, l=u''.join([unicode(s) for s in captions if type(s) in ASSFormatter.DISPLAYED_CC_STATEMENTS]))
    
    for c in captions:
      if type(c) in ASSFormatter.DISPLAYED_CC_STATEMENTS:
        #invoke the handler for this object type
        WebVTTFormatter.DISPLAYED_CC_STATEMENTS[type(c)](self, c, timestamp)
      else:
        #TODO: Warning of unhandled characters
        pass
        #print str(type(c))


